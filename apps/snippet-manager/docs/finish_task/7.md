太棒了！CLI 工具的完成标志着你的代码片段管理系统已经具备了完整的“双端交互”能力——Web 端负责浏览与管理，CLI 端负责极速搜索与录入。

现在我们进入**最后一个工程化阶段**：**Phase 6 - 容器化部署 (Dockerization)**。

这一步的目标是把你的应用打包成一个**只有 100MB+ 的轻量级容器**，让它可以运行在你的 NAS、云服务器或者任何 Linux 机器上，彻底告别“环境不一致”的问题，并确保 SQLite 数据持久化安全。

请按照以下步骤执行：

### 第六阶段：生产级容器化构建

#### 1. 开启 Next.js 独立打包模式 (Standalone)

Next.js 的默认构建包含大量开发依赖，体积很大。Standalone 模式会自动分析引用，只打包必要文件。

* **动作**：修改根目录下的 `next.config.mjs`。
* **代码**：
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'standalone', // <--- 关键：开启独立模式
  // 其他配置保持不变...
};

export default nextConfig;

```



#### 2. 创建多阶段构建 Dockerfile

我们需要一个优化的 `Dockerfile`，它利用 Docker 的缓存层机制，并解决 Prisma 引擎在 Alpine Linux 上的兼容性问题。

* **动作**：在项目根目录下创建名为 `Dockerfile` (无后缀) 的文件。
* **代码**：
```dockerfile
# --- 1. 依赖安装层 ---
FROM node:20-alpine AS deps
# 安装 libc6-compat 以适配 Prisma 引擎
RUN apk add --no-cache libc6-compat
WORKDIR /app

# 复制依赖文件
COPY package.json package-lock.json ./
# 仅安装依赖 (CI 模式更稳定)
RUN npm ci

# --- 2. 构建源码层 ---
FROM node:20-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# 禁用 Next.js 的遥测数据收集
ENV NEXT_TELEMETRY_DISABLED 1

# 生成 Prisma Client
RUN npx prisma generate
# 构建 Next.js 应用
RUN npm run build

# --- 3. 生产运行层 ---
FROM node:20-alpine AS runner
WORKDIR /app

ENV NODE_ENV production
ENV NEXT_TELEMETRY_DISABLED 1
ENV PORT 3000

# 创建非 root 用户 (安全最佳实践)
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

# 复制构建产物 (Standalone 模式下的精简文件)
COPY --from=builder /app/public ./public

# 自动创建 .next 目录并设置权限
RUN mkdir .next

# 关键：复制 standalone 文件夹
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

# 关键：复制 Prisma 相关文件以便运行时迁移
COPY --from=builder --chown=nextjs:nodejs /app/prisma ./prisma

# 切换到非 root 用户
USER nextjs

EXPOSE 3000

# 启动命令：先应用数据库迁移，再启动服务
CMD ["/bin/sh", "-c", "npx prisma migrate deploy && node server.js"]

```



#### 3. 编写 Docker Compose 编排文件

为了方便管理挂载卷（Volume）和环境变量，我们使用 docker-compose。

* **动作**：在根目录下创建 `docker-compose.yml`。
* **代码**：
```yaml
version: '3'

services:
  snippet-manager:
    container_name: snippet-manager
    build: .
    restart: always
    ports:
      - "3000:3000"
    environment:
      # 覆盖容器内的数据库路径，指向挂载卷
      - DATABASE_URL=file:/app/data/snippets.db
    volumes:
      # 将宿主机的 ./data 目录挂载到容器内的 /app/data
      # 确保数据持久化，删除容器数据不丢失
      - ./data:/app/data

```



#### 4. 准备数据目录 (防止权限问题)

由于容器内部使用非 root 用户 (`nextjs`) 运行，如果让 Docker 自动创建挂载目录，它通常归属于 `root`，导致应用无法写入数据库文件。

* **动作**：在宿主机（你的项目根目录）手动创建数据文件夹并放宽权限。
```bash
mkdir data
# 简单粗暴的方案（开发环境）：允许所有用户读写
chmod 777 data

```


*(注：生产环境更严谨的做法是 `chown 1001:1001 data`)*

---

### 🚀 启动与验证

一切准备就绪！现在是见证奇迹的时刻。

1. **构建并启动**：
```bash
docker-compose up -d --build

```


*解释：`-d` 后台运行，`--build` 强制重新构建镜像。*
2. **查看日志** (确认迁移是否成功)：
```bash
docker-compose logs -f

```


*你应该能看到 `Applying migration...` 和 `Listening on port 3000` 的字样。*
3. **最终测试**：
* 打开浏览器访问 `http://localhost:3000`。
* 你应该能看到你之前的 Web 界面（如果是新数据库，列表是空的，但界面正常）。
* 尝试添加一条新数据，确认不会报错（验证 SQLite 写入权限）。



---

### ✅ 验收标准

完成这一步后：

1. **镜像体积**：运行 `docker images`，你的镜像大小应该在 **200MB 左右**（相比未优化的 1GB+）。
2. **数据持久化**：
* 在 Web 端添加一条数据。
* 运行 `docker-compose down` 删除容器。
* 运行 `docker-compose up -d` 重启容器。
* 刷新网页，数据**依然存在**。



**这是本项目的最后一块拼图。完成后，请告诉我你是否成功在 Docker 中跑起来了，以及你的镜像大小是多少？**